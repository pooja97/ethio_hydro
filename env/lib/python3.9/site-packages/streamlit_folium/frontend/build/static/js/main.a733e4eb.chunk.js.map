{"version":3,"sources":["circle-to-polygon.tsx","index.tsx"],"names":["earthRadius","toRadians","angleInDegrees","Math","PI","toDegrees","angleInRadians","offset","c1","distance","bearing","lat1","lon1","dByR","lat","asin","sin","cos","atan2","onMapClick","e","window","__GLOBAL_DATA__","lat_lng_clicked","latlng","debouncedUpdateComponentValue","map","debounce","updateComponentValue","global_data","bounds","getBounds","zoom","getZoom","Streamlit","setComponentValue","last_clicked","last_object_clicked","all_drawings","last_active_drawing","last_circle_radius","last_circle_polygon","center","getCenter","onMapMove","onDraw","type","layerType","layer","_latlng","lng","radius","options","polygon","sides","coordinates","i","push","circleToPolygon","onLayerClick","details","toGeoJSON","drawn_items","features","initComponent","key","on","_layers","setFrameHeight","events","addEventListener","RENDER_EVENT","event","data","detail","fig","args","height","width","div1","document","getElementById","div2","style","indexOf","a","createElement","href","id","innerHTML","body","appendChild","render_script","setComponentReady"],"mappings":"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","file":"static/js/main.a733e4eb.chunk.js","sourcesContent":["const earthRadius = 6378137; // equatorial Earth radius in m\n\nfunction toRadians(angleInDegrees: number) {\n    return (angleInDegrees * Math.PI) / 180;\n}\n\nfunction toDegrees(angleInRadians: number) {\n    return (angleInRadians * 180) / Math.PI;\n}\n\nfunction offset(\n    c1: [number, number],\n    distance: number,\n    earthRadius: number,\n    bearing: number): [number, number] {\n    var lat1 = toRadians(c1[1]);\n    var lon1 = toRadians(c1[0]);\n    var dByR = distance / earthRadius;\n    var lat = Math.asin(\n        Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n    );\n    var lon =\n        lon1 +\n        Math.atan2(\n            Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n            Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n        );\n    return [toDegrees(lon), toDegrees(lat)];\n}\n\nexport function circleToPolygon(center: [number, number], radius: number, sides: number = 32) {\n    var coordinates = [];\n    for (var i = 0; i < sides; ++i) {\n        coordinates.push(\n            offset(\n                center, radius, earthRadius, (2 * Math.PI * i) / sides\n            )\n        );\n    }\n    coordinates.push(coordinates[0]);\n\n    return {\n        type: \"Polygon\",\n        coordinates: [coordinates],\n    };\n};","import { Streamlit, RenderData } from \"streamlit-component-lib\"\nimport { debounce } from \"underscore\"\nimport { circleToPolygon } from \"./circle-to-polygon\"\n\ntype GlobalData = {\n  lat_lng_clicked: any\n  last_object_clicked: any\n  last_active_drawing: any\n  all_drawings: any\n  zoom: any\n  drawn_items: any\n  last_circle_radius: number | null\n  last_circle_polygon: any\n}\n\ndeclare global {\n  interface Window {\n    __GLOBAL_DATA__: GlobalData\n    initComponent: any\n    map: any\n  }\n}\n\nfunction onMapClick(e: any) {\n  const global_data = window.__GLOBAL_DATA__\n  global_data.lat_lng_clicked = e.latlng\n  debouncedUpdateComponentValue(window.map)\n}\n\nlet debouncedUpdateComponentValue = debounce(updateComponentValue, 250)\n\nfunction updateComponentValue(map: any) {\n  const global_data = window.__GLOBAL_DATA__\n  let bounds = map.getBounds()\n  let zoom = map.getZoom()\n  Streamlit.setComponentValue({\n    last_clicked: global_data.lat_lng_clicked,\n    last_object_clicked: global_data.last_object_clicked,\n    all_drawings: global_data.all_drawings,\n    last_active_drawing: global_data.last_active_drawing,\n    bounds: bounds,\n    zoom: zoom,\n    last_circle_radius: global_data.last_circle_radius,\n    last_circle_polygon: global_data.last_circle_polygon,\n    center: map.getCenter(),\n  })\n}\n\nfunction onMapMove(e: any) {\n  debouncedUpdateComponentValue(window.map)\n}\n\nfunction onDraw(e: any) {\n  const global_data = window.__GLOBAL_DATA__\n\n  var type = e.layerType,\n    layer = e.layer\n\n  if (type === \"circle\") {\n    var center: [number, number] = [layer._latlng.lng, layer._latlng.lat]\n    var radius = layer.options.radius // In km\n    var polygon = circleToPolygon(center, radius)\n    global_data.last_circle_radius = radius / 1000 // Convert to km to match what UI shows\n    global_data.last_circle_polygon = polygon\n  }\n  return onLayerClick(e)\n}\n\nfunction onLayerClick(e: any) {\n  const global_data = window.__GLOBAL_DATA__\n  global_data.last_object_clicked = e.latlng\n  let details: Array<any> = []\n  if (e.layer && e.layer.toGeoJSON) {\n    global_data.last_active_drawing = e.layer.toGeoJSON()\n  }\n  if (global_data.drawn_items.toGeoJSON) {\n    details = global_data.drawn_items.toGeoJSON().features\n  }\n  global_data.all_drawings = details\n  debouncedUpdateComponentValue(window.map)\n}\n\nwindow.initComponent = (map: any) => {\n  map.on(\"click\", onMapClick)\n  map.on(\"moveend\", onMapMove)\n  for (let key in map._layers) {\n    let layer = map._layers[key]\n    layer.on(\"click\", onLayerClick)\n  }\n  map.on(\"draw:created\", onDraw)\n  map.on(\"draw:edited\", onDraw)\n  map.on(\"draw:deleted\", onDraw)\n\n  Streamlit.setFrameHeight()\n  updateComponentValue(map)\n}\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  const fig: string = data.args[\"fig\"]\n  const height: number = data.args[\"height\"]\n  const width: number = data.args[\"width\"]\n\n  if (!window.map) {\n    // Only run this if the map hasn't already been created (and thus the global\n    //data hasn't been initialized)\n    const div1 = document.getElementById(\"map_div\")\n    const div2 = document.getElementById(\"map_div2\")\n    if (div2) {\n      div2.style.height = `${height}px`\n      div2.style.width = `${width}px`\n    }\n    if (div1) {\n      div1.style.height = `${height}px`\n      div1.style.width = `${width}px`\n\n      if (fig.indexOf(\"document.getElementById('export')\") !== -1) {\n        let a = document.createElement(\"a\")\n        a.href = \"#\"\n        a.id = \"export\"\n        a.innerHTML = \"Export\"\n        document.body.appendChild(a)\n      }\n\n      const render_script = document.createElement(\"script\")\n      // HACK -- update the folium-generated JS to add, most importantly,\n      // the map to this global variable so that it can be used elsewhere\n      // in the script.\n\n      window.__GLOBAL_DATA__ = {\n        lat_lng_clicked: null,\n        last_object_clicked: null,\n        all_drawings: null,\n        last_active_drawing: null,\n        zoom: null,\n        drawn_items: [],\n        last_circle_radius: null,\n        last_circle_polygon: null,\n      }\n      // The folium-generated script creates a variable called \"map_div\", which\n      // is the actual Leaflet map.\n      render_script.innerHTML =\n        fig + `window.map = map_div; window.initComponent(map_div);`\n      document.body.appendChild(render_script)\n    }\n  }\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}